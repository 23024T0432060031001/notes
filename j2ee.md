- [Creating Session EJB Components](#creating-session-ejb-components)
____

### Creating Session EJB Components

- A client first accesses a session bean's home interface through JNDI lookup.
  Using the `create` method on the home interface, the client creates an EJB
  object which implements the session bean's remote (or local) interface. The
  client then accesses the business methods of a session bean through this
  interface.
- The time between creating and removing the session bean is considered the
  client's session.
- Stateful session bean instance exists until either the client explicitly
  removes the bean or until the session times out. When the client makes further
  requests, those requests are made to the same bean within the context of any
  prior requests. Each stateful session bean belongs to a specific client.
  Therefore, the container must maintain a separate EJB object (kind of on
  client side) and EJB instance (on container side) for each client requesting
  an EJB component (implies one-to-one relationship).
- To minimize memory consumption, a container might implement a mechanism for
  swapping out inactive stateful session bean instances, called passivation.
- The container vendor might implement the stateless session bean interface to
  use one EJB object reference to handle all client requests or create
  a separate EJB object reference for each client.
- The pool size of bean instances depends on number of requests rather than
  number of clients.
- The statefulness of session bean is transparent to client developer.  The use
  of stateless session beans gives a throughput advantage in all
  practical cases.
- The home interface and remote interface are accessible to the client
  programmer and are implemented by classes generated by the container.
- The bean class contains business methods and infrastructure methods called by
  the container. The client developer never requires, or obtains, direct access
  to the bean class.
- In session bean, the creator methods on the home interface must match those
  on the bean class. These methods must have matching parameter list. However,
  methods on the home interface returns an EJB object while those on bean class
  returns void. Similarly, each business method signature must appear on both
  the remote interface and the bean class.
- Session bean implements `javax.ejb.SessionBean` interface which requires
  `setSessionContext`, `ejbPassivate`, `ejbActivate`, `ejbRemove`.
- For stateful session beans, the home object creates a new instance of the
  EJB object, the session context object and the bean implementation class. As
  part of initialization, the home object calls `setSessionContext()` and
  followed by an appropriate `ejbCreate()`.
- The client calls business methods on its reference to the EJB object created
  by the container. The EJB object then calls the corresponding method on the
  implementation instance.
- For stateless session beans, the container determines when the bean class is
  instantiated and initialized; this process is not driven by the client.
  Methods `setSessionContext()` and `ejbCreate()` are called but container
  determines the time to perform these tasks. The `ejbPassivate()` and
  `ejbActivate()` methods are never called, `ejbRemove()` is unlikely to be
  called.
- The container supplies the bean instance with a `SessionContext` object. The
  bean instance can save the `SessionContext` object as a field, and then use it
  within business methods to gain access to the associated EJB home and EJB
  object, to the current transaction state, and to security information. The
  bean provider should code the `setSessionContext` method to store the
  `SessionContext` object so that it can be used later.

